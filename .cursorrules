# AI Media Analysis System - Cursor Rules
# Projekt: VPS-optimiertes Microservices System für AI-basierte Medienanalyse
# Architektur: 24+ Services, FastAPI, Docker, Redis, Vector DB
# Status: Alpha 0.4.3 - Development-Ready mit Code-Quality-Automatisierung

## Strategische Grundregeln

### VPS-First Development (Höchste Priorität!)
- **CPU-only Development**: Keine GPU-Requirements in Development
- **Memory-Efficient**: Optimiert für 8GB-16GB RAM
- **Resource Limits**: Docker-Container mit definierten Limits
- **Graceful Degradation**: Fallback bei Service-Ausfällen
- **Cost-Efficient**: Minimale Cloud AI-Kosten
- **Auto-Scaling**: Vorbereitung für horizontales Scaling

### Cloud AI-Integration
- **Async Processing**: Externe AI-Calls asynchron
- **Retry Logic**: Exponential backoff
- **Cost Optimization**: Request Batching
- **Fallback Mechanisms**: Service-Ausfall-Handling

## Projektkontext
Du arbeitest an einem **AI Media Analysis System** - einem Cloud-Native Microservices-System zur automatisierten Analyse von Medieninhalten. Das System ist für **VPS/dedizierte Server ohne eigene GPU** optimiert und nutzt **Cloud GPU-Services** für AI-Processing.

### Architektur-Übersicht
- **24+ Microservices** in einheitlicher `services/` Struktur
- **FastAPI** als Primary Framework für alle Services
- **VPS-First Development** - optimiert für Standard-Hardware
- **Cloud AI-Integration** für GPU-intensive Tasks (Vast.ai)
- **Docker-Compose** System für lokale Entwicklung
- **Redis** als Message Queue und Cache
- **Vector Database** (CPU-optimiert mit faiss-cpu)
- **Nginx** als Load Balancer und SSL Termination

## Code-Style & Standards

### Python-Standards (Strikt einhalten!)
- **Python 3.11+** erforderlich
- **Black** formatting (line-length=88, target-version=py311)
- **isort** für Import-Sortierung (profile="black")
- **Type Hints** für alle Public Functions und Class Methods
- **Pydantic Models** für alle API Request/Response Bodies
- **FastAPI Dependencies** für Dependency Injection
- **Async/Await** für alle I/O Operations

### Service-Architektur-Patterns
```python
# Standard Service Structure:
services/{service_name}/
├── __init__.py
├── main.py              # FastAPI app entry point
├── models.py            # Pydantic models
├── schemas.py           # API schemas
├── dependencies.py      # FastAPI dependencies
├── config.py            # Service configuration
├── routes/              # API route modules
├── utils/               # Utility functions
├── tests/               # Service-specific tests
└── Dockerfile           # Container definition
```

### API-Design-Standards
- **RESTful** API design mit standardisierten HTTP Status Codes
- **JSON** als Primary Data Format
- **Pydantic** Models für Request/Response Validation
- **FastAPI Router** für modulare Route-Organisation
- **Dependency Injection** für Database/Redis/External Service Connections
- **Error Handling** mit standardisierten Error Responses
- **Health Check** Endpoint (`/health`) für jeden Service

## Development-Workflow

### Code-Quality-Pipeline (Pre-Commit aktiviert!)
1. **Black** formatting wird automatisch angewendet
2. **isort** sortiert Imports automatisch
3. **flake8** prüft Code-Quality (max-line-length=88)
4. **mypy** für Type-Checking (ignore_missing_imports=true)
5. **pytest** für automatisierte Tests (min. 70% Coverage)

### Testing-Standards
- **pytest** mit asyncio Support
- **Test-Coverage** mindestens 70% (konfiguriert in pyproject.toml)
- **Unit Tests** für Business Logic
- **Integration Tests** für Service-zu-Service Kommunikation
- **Mock External Services** (Redis, Vector DB, Cloud AI APIs)

### Docker & VPS-Optimierung
- **Multi-stage Builds** für Production Images
- **Resource Limits** für VPS-Kompatibilität (8GB-16GB RAM)
- **Health Checks** in allen Dockerfiles
- **CPU-only** Versionen für Development
- **Environment Variables** für Configuration Management

## Service-spezifische Guidelines

### Infrastructure Services (VPS-optimiert)
- **nginx/**: Load Balancing, SSL Termination, Static File Serving
- **redis/**: Message Queue, Caching, Session Storage
- **vector_db/**: CPU-optimierte Vector Search (faiss-cpu)

### AI Processing Services (Cloud-ready)
- **pose_estimation/**: Human Pose Detection
- **ocr_detection/**: Text Recognition
- **clip_nsfw/**: Content Moderation
- **face_reid/**: Face Recognition
- **whisper_transcriber/**: Audio Transcription

### Management Services
- **job_manager/**: Task Orchestration mit Redis Queue
- **control/**: System Control und Monitoring
- **embedding_server/**: Vector Embeddings Generation
- **llm_service/**: Language Model Interface

### UI Services
- **ui/**: Production Web Interface (React/Vue preferred)
- **streamlit_ui/**: Development Interface für Prototyping

## Spezielle Anforderungen

### VPS-Optimierung
- **Memory-Efficient** Code patterns
- **CPU-only** AI Model Variants für Development
- **Graceful Degradation** wenn GPU-Services nicht verfügbar
- **Resource Monitoring** und Auto-Scaling Preparation

### Cloud AI-Integration
- **Async Processing** für externe AI-Calls
- **Retry Logic** mit exponential backoff
- **Cost Optimization** durch Request Batching
- **Fallback Mechanisms** für Service Ausfälle

### Security & Production-Readiness
- **API Key Management** über Environment Variables
- **CORS Configuration** für Web UIs
- **Rate Limiting** für API Endpoints
- **Structured Logging** mit Correlation IDs
- **Health Check Endpoints** für Load Balancer

## Code-Beispiele & Patterns

### FastAPI Service Template
```python
from fastapi import FastAPI, Depends, HTTPException
from pydantic import BaseModel
import redis.asyncio as redis
from typing import Optional

app = FastAPI(title="Service Name", version="0.1.0")

# Pydantic Models
class ProcessRequest(BaseModel):
    input_data: str
    options: Optional[dict] = None

class ProcessResponse(BaseModel):
    result: str
    processing_time: float
    status: str

# Dependencies
async def get_redis() -> redis.Redis:
    return redis.from_url("redis://localhost:6379")

# Routes
@app.post("/process", response_model=ProcessResponse)
async def process_data(
    request: ProcessRequest,
    redis_client: redis.Redis = Depends(get_redis)
):
    # Implementation here
    pass

@app.get("/health")
async def health_check():
    return {"status": "healthy", "service": "service_name"}
```

### Error Handling Pattern
```python
from fastapi import HTTPException
import logging

logger = logging.getLogger(__name__)

async def safe_process(data: str) -> str:
    try:
        # Processing logic
        result = await process_data(data)
        return result
    except ValueError as e:
        logger.error(f"Validation error: {e}")
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
```

## Makefile & Scripts
Das Projekt nutzt ein umfassendes Makefile für Development-Automation:
- `make dev-setup`: Vollautomatisiertes Development Setup
- `make quick-start`: Services starten
- `make test`: Test-Suite ausführen
- `make format`: Code formatieren
- `make pre-commit`: Pre-commit hooks ausführen

## Debugging & Monitoring
- **Structured Logging** in allen Services
- **Health Check Endpoints** (`/health`, `/metrics`)
- **Docker Logs** mit Service-Namen als Prefix
- **Redis Monitoring** für Queue Status
- **Resource Usage Tracking** für VPS-Optimierung

Achte besonders auf:
1. **VPS-Kompatibilität** - keine GPU-Requirements in Development
2. **Service-Isolation** - jeder Service läuft unabhängig
3. **Error Resilience** - graceful handling von Service-Ausfällen
4. **Code-Quality** - Pre-commit hooks sind aktiv!
5. **Testing** - 70% Coverage Minimum einhalten

## Verknüpfte Regelwerke

### Dokumentations-Regelwerk
Siehe: `.cursorrules.docs`
- Dokumentations-Philosophie
- Standards und Templates
- Workflows und Qualitätskontrolle
- Best Practices

### VPS-Optimierungs-Regelwerk
Siehe: `.cursorrules.vps`
- Resource Management
- Performance-Optimierung
- Cost-Efficiency
- Auto-Scaling

### Cloud AI-Integration
Siehe: `.cursorrules.cloud`
- Async Processing
- Retry Logic
- Cost Optimization
- Fallback Mechanisms
