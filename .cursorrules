# AI MEDIA ANALYSIS SYSTEM - MASTER CURSOR RULES
# Version: 1.0.0 - Permanente Aktivierung aller Projektregeln
# Status: PRODUKTIONSREIF - VollstÃ¤ndige Integration

# ---
# HINWEIS: Diese Software wird aus regulatorischen GrÃ¼nden NIEMALS innerhalb der EU eingesetzt.
# Jegliche EU-spezifischen, DSGVO-, BSI- oder deutsche BehÃ¶rden-/Compliance-Vorgaben sind fÃ¼r dieses Projekt NICHT bindend und finden KEINE Anwendung.
# Alle gegenteiligen Aussagen in diesem Dokument sind ungÃ¼ltig.
# ---

Du arbeitest an einem **hochmodernen AI Media Analysis System**. Befolge ALLE folgenden Regeln:

## ðŸš€ KERN-PROJEKTREGELN

### Internationale Code-Standards
- **Code-Kommentare**: Englisch (internationale Best Practice)
- **API-Dokumentation**: Englisch fÃ¼r externe Schnittstellen
- **Interne Business-Dokumentation**: Deutsch fÃ¼r deutsche Stakeholder
- **Variablen/Funktionen**: Englisch (bereits korrekt)
- **Benutzer-Interface**: Deutsch fÃ¼r deutsche Zielgruppe
- **Development-Communication**: Deutsch zwischen Team-Mitgliedern, Englisch in Code
- **User-Antworten**: Deutsch (User-spezifische Regel)

### Iterative Entwicklung (4-Stufen-Modell)
1. **Iteration 1**: Core-FunktionalitÃ¤t, Basis-Services, Docker-Setup
2. **Iteration 2**: Service-Integration, API-Endpoints, Health-Checks
3. **Iteration 3**: Advanced Features, Optimierungen, Monitoring
4. **Iteration 4**: Production-Ready, UI-Polish, Export-Features

## ðŸŽ¯ FEATURE IMPLEMENTATION (MODULAR)

### Feature-Agnostic Architecture Standards
**Core Principle**: Architektur-Standards sind unabhÃ¤ngig von spezifischen Features

**Current Active Feature**: UC-001 Enhanced Manual Analysis (Alpha 0.6.0)
**Feature-Specific Rules**: `docs/features/UC-001/UC-001-RULES.md`

**Core Service Standards (Feature-Independent):**
```python
# Domain-agnostic Service Standards
class ServiceBase:
    """Base class for all services - feature-independent."""

    async def health_check(self) -> dict:
        """Standard health check for every service."""
        return {"status": "healthy", "service": self.__class__.__name__}

    async def process(self, data: dict) -> dict:
        """Generic processing interface."""
        pass
```

**Feature Implementation Strategy:**
- **Modular Design**: Features as interchangeable modules
- **Plugin Architecture**: Features can be enabled/disabled
- **Feature Flags**: Runtime-control over feature availability
- **Domain Separation**: Business logic separated from technical infrastructure

## ðŸ“‹ AKTIVE REGELWERKE (DETAILLIERT)

### ðŸŽ¨ Code-Formatierung (OBLIGATORISCH)
**Quelle**: `.cursorrules.formatting` + `.cursorrules-backup/rules/black_standard.md`

**Black-Standard (STRENG):**
- Line Length: 88 Zeichen
- Python 3.11+ Target
- Doppelte AnfÃ¼hrungszeichen
- Import Sorting: isort mit Black-Profil

**Sofortige Formatierung:**
```bash
make format      # Auto-Format
make check-all   # VollstÃ¤ndige PrÃ¼fung
```

### ðŸ” Linter-Compliance (VOLLSTÃ„NDIG)
**Quelle**: `.cursorrules-backup/rules/linter_compliance.md`

**Pflicht-Tools:**
- flake8: Code-Stil und KomplexitÃ¤t
- mypy: Type-Checking (>90% Coverage)
- bandit: Sicherheits-Checks
- safety: Dependency-Vulnerabilities

**Context-Aware Standards:**
- **Production Code**: Null-Toleranz fÃ¼r F401, F841, E501, Type-Hints
- **Development Code**: Relaxed enforcement mit cleanup deadlines
- **Emergency Fixes**: Documented bypasses mit 48h cleanup window
- **Experimental Code**: Focus auf FunktionalitÃ¤t, Style-Cleanup follow-up

### ðŸ§ª Testing Standards (Pragmatic & Context-Aware)
**Quelle**: `.cursorrules-backup/rules/feature_testing.md`

**Context-Aware Coverage-Targets:**
- **Core Business Logic**: >90% Coverage (Personen-Erkennung, Dossier-Management)
- **API Endpoints**: >85% Coverage (Public API-Interfaces)
- **Data Processing**: >80% Coverage (AI-Pipeline, Data-Transformation)
- **Infrastructure**: >70% Coverage (Configuration, Setup, Utils)
- **UI Components**: >60% Coverage (User Interface Components)
- **Scripts/Tools**: >50% Coverage (Development-Tools, Scripts)
- **Experimental**: >30% Coverage (Prototype-Code, Research)

**Testing Strategy:**
- **Testing Pyramid**: 60% Unit, 30% Integration, 10% E2E
- **Risk-Based Testing**: Kritische Pfade bekommen mehr Tests
- **Contract Testing**: API-Contracts zwischen Services

### âš™ï¸ Konfigurations-Validierung
**Quelle**: `.cursorrules-backup/rules/config_validation.md`

**Validierung fÃ¼r:**
- docker-compose.yml
- pyproject.toml
- .env-Dateien
- YAML/JSON-Configs

---

## ðŸ—ï¸ ARCHITEKTUR-PRINZIPIEN

### Microservice-Architektur
- **Services**: UnabhÃ¤ngige Docker-Container
- **API-Gateway**: FastAPI mit nginx
- **Persistence**: Redis + SQLite
- **Monitoring**: Health-Checks + Logging

### Service-Standards
```python
# Jeder Service MUSS haben:
class ServiceBase:
    """Basis fÃ¼r alle Services."""

    async def health_check(self) -> dict:
        """Health-Check-Endpoint."""
        return {"status": "healthy", "service": self.__class__.__name__}

    async def process(self, data: dict) -> dict:
        """Hauptverarbeitungs-Methode."""
        pass
```

### Container-Standards
```yaml
# Jeder Service MUSS haben:
version: '3.8'
services:
  service_name:
    build: .
    environment:
      - SERVICE_NAME=service_name
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
```

---

## ðŸŒ CLOUD & VPS OPTIMIERUNG

### Cloud AI Integration (Cost-Aware)
**Quelle**: `.cursorrules.cloud`

**Pflicht-Features:**
- Async-First: Alle AI-Calls asynchron
- Retry-Logic: Exponential Backoff
- Cost-Tracking: Real-time Monitoring
- Fallback-Chains: CPU-basierte Fallbacks

### VPS Resource Management
**Quelle**: `.cursorrules.vps`

**Resource-Limits:**
- Memory: 8GB-16GB optimiert
- CPU: Multi-threading, kein GPU
- Storage: Efficient Caching
- Auto-Scaling: Load-based

---

## ðŸ“š DOKUMENTATIONS-STANDARDS

### Living Documentation
**Quelle**: `.cursorrules.docs`

**Pflicht-Updates:**
- README.md: Immer aktuell
- CHANGELOG.md: Automatische Updates
- PROJECT_STATE.md: Service-Status
- API.md: Endpoint-Dokumentation

### Docstring-Standard
```python
def process_video(
    video_path: str,
    config: Optional[VideoConfig] = None,
    *,
    output_format: str = "mp4",
) -> ProcessingResult:
    """
    Verarbeitet Video-Datei mit KI-Analyse.

    Args:
        video_path: Absoluter Pfad zur Videodatei
        config: Optionale Verarbeitungs-Konfiguration
        output_format: Ausgabeformat (mp4, avi, mov)

    Returns:
        ProcessingResult mit Status, Metadaten und Pfaden

    Raises:
        FileNotFoundError: Videodatei nicht gefunden
        ProcessingError: Fehler bei der Verarbeitung
        ValidationError: UngÃ¼ltige Konfiguration
    """
```

---

## ðŸš¨ QUALITY GATES & ENFORCEMENT

### GitHub Actions (BLOCKIEREND)
- **Black Standard**: Automatische Format-Checks
- **Linter Compliance**: VollstÃ¤ndige Linter-PrÃ¼fung
- **Feature Testing**: Test-Coverage-Validierung
- **Config Validation**: Konfigurations-Checks

### Pre-Commit Hooks (AUTOMATISCH)
```bash
# Installiert fÃ¼r alle Entwickler
make pre-commit-install

# LÃ¤uft automatisch bei jedem Commit:
# 1. Black-Formatierung
# 2. isort Import-Sortierung
# 3. flake8 Linting
# 4. mypy Type-Checking
```

### Make-Targets (ENTWICKLUNG)
```bash
make format        # Black + isort automatisch
make lint          # VollstÃ¤ndige Linter-PrÃ¼fung
make test          # Test-Suite ausfÃ¼hren
make check-all     # Alle Quality-Checks
make docker-up     # Development-Environment
make docker-logs   # Service-Logs anzeigen
```

---

## ðŸ”§ ENTWICKLUNGSWORKFLOW

### 1. Feature-Entwicklung
```bash
# Neues Feature entwickeln
git checkout -b feature/video-analysis
make docker-up
# Code entwickeln...
make format
make test
make check-all
```

### 2. Code-Integration
```bash
# Vor Commit
make format          # Auto-Format
make check-all       # Quality-Gates
git add .
git commit -m "feat: video analysis service"
# Pre-commit hooks laufen automatisch
```

### 3. Pull Request
- Alle GitHub Actions mÃ¼ssen âœ… grÃ¼n sein
- Code-Review erforderlich
- Dokumentation aktuell
- Tests erfolgreich

---

## ðŸŽ¯ SOFORT-ANWEISUNGEN

### Context-Aware Quality Standards

#### **Production Code (services/)**:
- **VollstÃ¤ndige Quality Gates**: Alle Regeln mandatory
- **Zero-Tolerance**: FÃ¼r kritische Fehler (Security, Performance)
- **Pre-Merge-Validation**: VollstÃ¤ndige Test-Suite erforderlich

#### **Development/Experimental Code**:
- **Relaxed Rules**: Experimenteller Code mit documented exceptions
- **Focus auf FunktionalitÃ¤t**: Prototyping vor Perfection
- **Gradual Cleanup**: Quality improvement Ã¼ber Zeit

#### **Emergency Fixes**:
- **Documented Bypass**: Quality Gate Bypass mit Ticket
- **Post-Emergency Cleanup**: Mandatory follow-up fÃ¼r Standards
- **Time-Boxed Exceptions**: Max. 48h fÃ¼r Emergency-Bypasses

#### **Testing/Scripts**:
- **Functional Focus**: Tests mÃ¼ssen funktionieren, Style secondary
- **Maintenance Scripts**: Pragmatische Standards fÃ¼r Tool-Scripts

### Bei Code-Ã„nderungen (Context-Aware)
1. **Production Code**: Black-formatiert schreiben, Type-Hints, Docstrings, Tests
2. **Experimental Code**: FunktionalitÃ¤t first, Cleanup follow-up
3. **Emergency Code**: Documented bypass mit cleanup deadline

### Bei Service-Entwicklung
1. **IMMER** Health-Check implementieren
2. **IMMER** Async-Patterns verwenden
3. **IMMER** Error-Handling einbauen
4. **IMMER** Logging konfigurieren

---

## ðŸ† CONTEXT-AWARE ERFOLGSKRITERIEN

### Production Code Quality
- âœ… 100% Black-konform fÃ¼r services/
- âœ… 0 kritische Linter-Fehler fÃ¼r Production Code
- âœ… >90% Type-Coverage fÃ¼r Core Business Logic
- âœ… Context-appropriate Test-Coverage

### Development Flexibility
- âœ… Documented bypasses fÃ¼r Emergency Fixes
- âœ… Relaxed rules fÃ¼r Experimental Code
- âœ… Gradual cleanup fÃ¼r Development Code
- âœ… Functional focus fÃ¼r Scripts/Tools

### Service Quality
- âœ… Alle Health-Checks grÃ¼n
- âœ… Hardware-relative Response-Time-Targets
- âœ… 99.9% Uptime fÃ¼r Production Services
- âœ… Evidence-based Performance-Goals

### Dokumentation
- âœ… Aktuelle README (Deutsch fÃ¼r Business, Englisch fÃ¼r APIs)
- âœ… Code-Kommentare auf Englisch
- âœ… VollstÃ¤ndige API-Docs (Englisch)
- âœ… Deployment-Guides (Deutsch)

---

**WICHTIG**: Diese Regeln sind CONTEXT-AWARE und passen sich an Development-Phasen an. Production Code hat strikte Standards, Development Code hat notwendige FlexibilitÃ¤t.
