# AI Media Analysis System - Cursor Rules
# Projekt: VPS-optimiertes Microservices System für AI-basierte Medienanalyse
# Architektur: 24+ Services, FastAPI, Docker, Redis, Vector DB
# Status: Alpha 0.4.3 - Development-Ready mit Code-Quality-Automatisierung

## Projektkontext
Du arbeitest an einem **AI Media Analysis System** - einem Cloud-Native Microservices-System zur automatisierten Analyse von Medieninhalten. Das System ist für **VPS/dedizierte Server ohne eigene GPU** optimiert und nutzt **Cloud GPU-Services** für AI-Processing.

### Architektur-Übersicht
- **24+ Microservices** in einheitlicher `services/` Struktur
- **FastAPI** als Primary Framework für alle Services
- **VPS-First Development** - optimiert für Standard-Hardware
- **Cloud AI-Integration** für GPU-intensive Tasks (Vast.ai)
- **Docker-Compose** System für lokale Entwicklung
- **Redis** als Message Queue und Cache
- **Vector Database** (CPU-optimiert mit faiss-cpu)
- **Nginx** als Load Balancer und SSL Termination

## Code-Style & Standards

### Python-Standards (Strikt einhalten!)
- **Python 3.11+** erforderlich
- **Black** formatting (line-length=88, target-version=py311)
- **isort** für Import-Sortierung (profile="black")
- **Type Hints** für alle Public Functions und Class Methods
- **Pydantic Models** für alle API Request/Response Bodies
- **FastAPI Dependencies** für Dependency Injection
- **Async/Await** für alle I/O Operations

### Service-Architektur-Patterns
```python
# Standard Service Structure:
services/{service_name}/
├── __init__.py
├── main.py              # FastAPI app entry point
├── models.py            # Pydantic models
├── schemas.py           # API schemas
├── dependencies.py      # FastAPI dependencies
├── config.py            # Service configuration
├── routes/              # API route modules
├── utils/               # Utility functions
├── tests/               # Service-specific tests
└── Dockerfile           # Container definition
```

### API-Design-Standards
- **RESTful** API design mit standardisierten HTTP Status Codes
- **JSON** als Primary Data Format
- **Pydantic** Models für Request/Response Validation
- **FastAPI Router** für modulare Route-Organisation
- **Dependency Injection** für Database/Redis/External Service Connections
- **Error Handling** mit standardisierten Error Responses
- **Health Check** Endpoint (`/health`) für jeden Service

## Development-Workflow

### Code-Quality-Pipeline (Pre-Commit aktiviert!)
1. **Black** formatting wird automatisch angewendet
2. **isort** sortiert Imports automatisch
3. **flake8** prüft Code-Quality (max-line-length=88)
4. **mypy** für Type-Checking (ignore_missing_imports=true)
5. **pytest** für automatisierte Tests (min. 70% Coverage)

### Testing-Standards
- **pytest** mit asyncio Support
- **Test-Coverage** mindestens 70% (konfiguriert in pyproject.toml)
- **Unit Tests** für Business Logic
- **Integration Tests** für Service-zu-Service Kommunikation
- **Mock External Services** (Redis, Vector DB, Cloud AI APIs)

### Docker & VPS-Optimierung
- **Multi-stage Builds** für Production Images
- **Resource Limits** für VPS-Kompatibilität (8GB-16GB RAM)
- **Health Checks** in allen Dockerfiles
- **CPU-only** Versionen für Development
- **Environment Variables** für Configuration Management

## Service-spezifische Guidelines

### Infrastructure Services (VPS-optimiert)
- **nginx/**: Load Balancing, SSL Termination, Static File Serving
- **redis/**: Message Queue, Caching, Session Storage
- **vector_db/**: CPU-optimierte Vector Search (faiss-cpu)

### AI Processing Services (Cloud-ready)
- **pose_estimation/**: Human Pose Detection
- **ocr_detection/**: Text Recognition
- **clip_nsfw/**: Content Moderation
- **face_reid/**: Face Recognition
- **whisper_transcriber/**: Audio Transcription

### Management Services
- **job_manager/**: Task Orchestration mit Redis Queue
- **control/**: System Control und Monitoring
- **embedding_server/**: Vector Embeddings Generation
- **llm_service/**: Language Model Interface

### UI Services
- **ui/**: Production Web Interface (React/Vue preferred)
- **streamlit_ui/**: Development Interface für Prototyping

## Spezielle Anforderungen

### VPS-Optimierung
- **Memory-Efficient** Code patterns
- **CPU-only** AI Model Variants für Development
- **Graceful Degradation** wenn GPU-Services nicht verfügbar
- **Resource Monitoring** und Auto-Scaling Preparation

### Cloud AI-Integration
- **Async Processing** für externe AI-Calls
- **Retry Logic** mit exponential backoff
- **Cost Optimization** durch Request Batching
- **Fallback Mechanisms** für Service Ausfälle

### Security & Production-Readiness
- **API Key Management** über Environment Variables
- **CORS Configuration** für Web UIs
- **Rate Limiting** für API Endpoints
- **Structured Logging** mit Correlation IDs
- **Health Check Endpoints** für Load Balancer

## Code-Beispiele & Patterns

### FastAPI Service Template
```python
from fastapi import FastAPI, Depends, HTTPException
from pydantic import BaseModel
import redis.asyncio as redis
from typing import Optional

app = FastAPI(title="Service Name", version="0.1.0")

# Pydantic Models
class ProcessRequest(BaseModel):
    input_data: str
    options: Optional[dict] = None

class ProcessResponse(BaseModel):
    result: str
    processing_time: float
    status: str

# Dependencies
async def get_redis() -> redis.Redis:
    return redis.from_url("redis://localhost:6379")

# Routes
@app.post("/process", response_model=ProcessResponse)
async def process_data(
    request: ProcessRequest,
    redis_client: redis.Redis = Depends(get_redis)
):
    # Implementation here
    pass

@app.get("/health")
async def health_check():
    return {"status": "healthy", "service": "service_name"}
```

### Error Handling Pattern
```python
from fastapi import HTTPException
import logging

logger = logging.getLogger(__name__)

async def safe_process(data: str) -> str:
    try:
        # Processing logic
        result = await process_data(data)
        return result
    except ValueError as e:
        logger.error(f"Validation error: {e}")
        raise HTTPException(status_code=400, detail=str(e))
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")
```

## Makefile & Scripts
Das Projekt nutzt ein umfassendes Makefile für Development-Automation:
- `make dev-setup`: Vollautomatisiertes Development Setup
- `make quick-start`: Services starten
- `make test`: Test-Suite ausführen
- `make format`: Code formatieren
- `make pre-commit`: Pre-commit hooks ausführen

## Debugging & Monitoring
- **Structured Logging** in allen Services
- **Health Check Endpoints** (`/health`, `/metrics`)
- **Docker Logs** mit Service-Namen als Prefix
- **Redis Monitoring** für Queue Status
- **Resource Usage Tracking** für VPS-Optimierung

Achte besonders auf:
1. **VPS-Kompatibilität** - keine GPU-Requirements in Development
2. **Service-Isolation** - jeder Service läuft unabhängig
3. **Error Resilience** - graceful handling von Service-Ausfällen
4. **Code-Quality** - Pre-commit hooks sind aktiv!
5. **Testing** - 70% Coverage Minimum einhalten

## Fortlaufende Dokumentation

### Dokumentations-Standards
- **Docstring-Format**: Google Style mit Type Hints
- **Markdown**: Für alle README und Dokumentationsdateien
- **Versionierung**: SemVer (MAJOR.MINOR.PATCH)
- **Changelog**: Automatische Updates bei Änderungen

### Service-Dokumentation
```python
def process_data(data: str) -> dict:
    """Verarbeitet die Eingabedaten und gibt das Ergebnis zurück.

    Args:
        data (str): Die zu verarbeitenden Daten im JSON-Format

    Returns:
        dict: Verarbeitetes Ergebnis mit Status und Metadaten

    Raises:
        ValueError: Bei ungültigem Datenformat
        ProcessingError: Bei Verarbeitungsfehlern
    """
    pass
```

### Automatische Dokumentations-Updates
1. **Code-Änderungen**:
   - Docstrings bei Funktionsänderungen aktualisieren
   - Type Hints bei Parameter-Änderungen anpassen
   - README.md bei API-Änderungen aktualisieren

2. **Service-Änderungen**:
   - `CHANGELOG.md` bei Feature/Service-Änderungen
   - `STATUS.md` bei Architektur-Änderungen
   - `API.md` bei Endpoint-Änderungen

3. **Architektur-Änderungen**:
   - `ARCHITECTURE.md` bei System-Änderungen
   - `DEPLOYMENT.md` bei Deployment-Änderungen
   - `DEVELOPMENT.md` bei Dev-Workflow-Änderungen

### Dokumentations-Templates

#### Service README Template
```markdown
# {Service Name}

## Beschreibung
Kurze Beschreibung des Service-Zwecks und der Hauptfunktionalität.

## API Endpoints
- `GET /health`: Health Check
- `POST /process`: Hauptverarbeitungsendpoint
- ...

## Konfiguration
- `REDIS_URL`: Redis Connection String
- `API_KEY`: Service API Key
- ...

## Entwicklung
```bash
# Setup
make dev-setup

# Tests
make test

# Start
make quick-start
```

## Monitoring
- Health Check: `/health`
- Metrics: `/metrics`
- Logs: `docker logs {service_name}`
```

#### Changelog Entry Template
```markdown
## [Unreleased]
### Added
- Neue Feature Beschreibung

### Changed
- Änderungen an bestehenden Features

### Fixed
- Bugfix Beschreibungen

### Removed
- Entfernte Features/Funktionalitäten
```

### Dokumentations-Workflow
1. **Code-Änderungen**:
   ```bash
   # 1. Code ändern
   # 2. Docstrings aktualisieren
   # 3. Tests schreiben/aktualisieren
   # 4. README aktualisieren
   make format
   make test
   ```

2. **Service-Änderungen**:
   ```bash
   # 1. Service-Code ändern
   # 2. API-Dokumentation aktualisieren
   # 3. Changelog aktualisieren
   # 4. Status-Dokumentation aktualisieren
   make update-docs
   ```

3. **Architektur-Änderungen**:
   ```bash
   # 1. Architektur-Änderungen implementieren
   # 2. ARCHITECTURE.md aktualisieren
   # 3. DEPLOYMENT.md aktualisieren
   # 4. Version bumpen
   make version-bump
   ```

### Dokumentations-Qualitätskontrolle
- **Pre-commit Hook**: Prüft Docstring-Format
- **CI/CD**: Validiert Markdown-Syntax
- **Review**: Dokumentation im Code-Review prüfen
- **Versioning**: Automatische Changelog-Generierung

### Wichtige Dokumentations-Dateien
- `README.md`: Projekt-Übersicht
- `CHANGELOG.md`: Änderungshistorie
- `STATUS.md`: Projekt-Status
- `API.md`: API-Dokumentation
- `ARCHITECTURE.md`: System-Architektur
- `DEVELOPMENT.md`: Entwicklungs-Workflow
- `DEPLOYMENT.md`: Deployment-Guide
- `CONTRIBUTING.md`: Beitrags-Richtlinien

### Dokumentations-Best-Practices
1. **Aktualität**: Dokumentation immer aktuell halten
2. **Klarheit**: Klare, präzise Formulierungen
3. **Beispiele**: Code-Beispiele für komplexe Features
4. **Struktur**: Konsistente Formatierung
5. **Links**: Querverweise zwischen Dokumenten
6. **Versioning**: Dokumentation mit Code versionieren
7. **Review**: Dokumentation im Code-Review prüfen
