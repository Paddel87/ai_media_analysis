# FORMATIERUNGS-REGELN FÃœR AI MEDIA ANALYSIS SYSTEM
# Version: 2.0.0 - Erweitert um obligatorischen Black-Standard
# Status: Obligatorisch fÃ¼r alle Entwickler

## ðŸŽ¨ NEUE OBLIGATORISCHE REGEL: BLACK-STANDARD COMPLIANCE

**WICHTIG**: Ab sofort mÃ¼ssen ALLE Python-Dateien dem strengen Black-Standard entsprechen!

ðŸ“‹ **Siehe detaillierte Regel**: `.cursorrules/rules/black_standard.md`

### Sofortige MaÃŸnahmen erforderlich:
1. **Code automatisch formatieren**: `make format`
2. **Pre-commit Hooks installieren**: `make pre-commit-install`
3. **Formatierung vor jedem Commit prÃ¼fen**: `make check-format`

---

## ðŸ”§ CODING-STYLE UND FORMATIERUNG

### Black Code Formatter (OBLIGATORISCH)
- **Einstellung**: Strenger Black-Standard ohne Anpassungen
- **Line Length**: Maximal 88 Zeichen (Black-Standard)
- **Target Version**: Python 3.11+
- **String Quotes**: Doppelte AnfÃ¼hrungszeichen bevorzugt
- **Import Sorting**: isort mit Black-Profil

```python
# âœ… KORREKT - Black-konform
def process_video_data(
    video_path: str,
    output_dir: str,
    config: Optional[Dict[str, Any]] = None,
    *,
    batch_size: int = 1,
) -> Dict[str, Any]:
    """Verarbeitet Video-Daten mit konfigurierbaren Parametern."""
    if not os.path.exists(video_path):
        raise FileNotFoundError(f"Video nicht gefunden: {video_path}")

    return {
        "status": "success",
        "processed_frames": 0,
        "output_path": output_dir,
        "metadata": {"batch_size": batch_size},
    }
```

### Import-Organisation mit isort
```python
# Standard Library
import os
import sys
from typing import Dict, List, Optional

# Third Party
import redis
import uvicorn
from fastapi import FastAPI, HTTPException

# Local Imports
from services.common.config import Config
from services.common.utils import logger
```

### Code-Formatierungs-Befehle
```bash
# Automatische Formatierung (empfohlen)
make format

# Formatierungs-Check ohne Ã„nderungen
make check-format

# Strenger CI/CD-Check
make format-check-strict
```

## ðŸ“ DOCSTRING-STANDARDS

### Funktions-Docstrings
```python
def analyze_video_content(
    video_path: str,
    analysis_types: List[str],
    confidence_threshold: float = 0.8
) -> AnalysisResult:
    """
    Analysiert Video-Inhalte mit verschiedenen AI-Modellen.

    Args:
        video_path: Pfad zur zu analysierenden Videodatei
        analysis_types: Liste der durchzufÃ¼hrenden Analysen
        confidence_threshold: Mindest-Konfidenz fÃ¼r Ergebnisse

    Returns:
        AnalysisResult mit detaillierten Analyseergebnissen

    Raises:
        FileNotFoundError: Wenn Videodatei nicht existiert
        ValidationError: Bei ungÃ¼ltigen Analyse-Typen

    Example:
        >>> result = analyze_video_content(
        ...     "video.mp4",
        ...     ["nsfw", "objects", "faces"],
        ...     confidence_threshold=0.9
        ... )
        >>> print(result.summary)
    """
```

### Klassen-Docstrings
```python
class VideoProcessor:
    """
    Video-Verarbeitungsservice fÃ¼r AI-Media-Analysis.

    Diese Klasse koordiniert die Video-Analyse durch verschiedene
    AI-Services und aggregiert die Ergebnisse.

    Attributes:
        config: Service-Konfiguration
        redis_client: Redis-Verbindung fÃ¼r Caching
        active_jobs: Dictionary der aktuell laufenden Jobs

    Example:
        >>> processor = VideoProcessor(config)
        >>> result = await processor.process_video("input.mp4")
    """
```

## ðŸ—ï¸ NAMENSKONVENTIONEN

### Python Naming Standards (Black-kompatibel)
- **Funktionen/Variablen**: `snake_case`
- **Klassen**: `PascalCase`
- **Konstanten**: `UPPER_SNAKE_CASE`
- **Module**: `lowercase_with_underscores`
- **Private Attributes**: `_leading_underscore`

### Service-spezifische Namen
```python
# âœ… KORREKT
class LLMService:
    """Large Language Model Service"""

    def __init__(self):
        self.model_name = "gpt-4"
        self.max_tokens = 4096
        self._api_key = os.getenv("OPENAI_API_KEY")

    async def analyze_text(self, text: str) -> AnalysisResult:
        """Analysiert Text mit LLM"""
        pass

# Konstanten
DEFAULT_BATCH_SIZE = 32
MAX_VIDEO_DURATION = 3600
SUPPORTED_FORMATS = ["mp4", "avi", "mov"]
```

## ðŸ”’ TYPE HINTS (Erweitert fÃ¼r Black-Compliance)

### VollstÃ¤ndige Type Annotations
```python
from typing import Dict, List, Optional, Union, Any, Callable
from pathlib import Path

def process_media_batch(
    media_files: List[Path],
    processors: Dict[str, Callable[[Path], Any]],
    output_config: Optional[Dict[str, Union[str, int]]] = None,
    *,
    parallel: bool = True,
    max_workers: int = 4,
) -> Dict[str, List[Any]]:
    """Verarbeitet mehrere Medien-Dateien parallel."""
    pass
```

### Moderne Python Features
```python
# Python 3.10+ Union Syntax (wenn verfÃ¼gbar)
def get_analysis_result(video_id: str) -> dict[str, str | int | None]:
    """Moderne Type Hint Syntax"""
    pass

# Generics
from typing import TypeVar, Generic

T = TypeVar('T')

class ProcessingResult(Generic[T]):
    """Generisches Verarbeitungsresultat"""

    def __init__(self, data: T, metadata: dict[str, Any]) -> None:
        self.data = data
        self.metadata = metadata
```

## ðŸ§ª TESTING-CODE FORMATIERUNG

### Test-Struktur (Black-konform)
```python
class TestVideoProcessor:
    """Test-Klasse fÃ¼r VideoProcessor"""

    @pytest.fixture
    def mock_video_data(self) -> Dict[str, Any]:
        """Mock-Video-Daten fÃ¼r Tests"""
        return {
            "path": "/tmp/test_video.mp4",
            "duration": 120,
            "fps": 30,
            "resolution": "1920x1080",
        }

    async def test_process_video_success(
        self,
        mock_video_data: Dict[str, Any],
        mock_redis: MockRedis,
    ) -> None:
        """Test erfolgreiche Video-Verarbeitung"""
        # Given
        processor = VideoProcessor(config=test_config)

        # When
        result = await processor.process(mock_video_data)

        # Then
        assert result.status == "completed"
        assert result.frame_count > 0
        mock_redis.set.assert_called_once()
```

## ðŸ“ DATEI-ORGANISATION

### Service-Verzeichnis-Struktur (Black-formatiert)
```
services/
â”œâ”€â”€ llm_service/
â”‚   â”œâ”€â”€ __init__.py              # Leere __init__ oder Exports
â”‚   â”œâ”€â”€ main.py                  # FastAPI App (Black-formatiert)
â”‚   â”œâ”€â”€ models.py                # Pydantic Models
â”‚   â”œâ”€â”€ processors.py            # Business Logic
â”‚   â”œâ”€â”€ config.py                # Konfiguration
â”‚   â””â”€â”€ requirements.txt         # Dependencies
```

### Import-Struktur pro Datei
```python
"""
Modul-Docstring hier.

Beschreibung des Moduls und seiner FunktionalitÃ¤t.
"""

# Standard Library Imports
import os
import sys
from datetime import datetime
from typing import Dict, List, Optional

# Third Party Imports
import redis
import uvicorn
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel

# Local Application Imports
from services.common.config import Config
from services.common.logging import get_logger
from services.common.utils import validate_input

# Konstanten
LOGGER = get_logger(__name__)
DEFAULT_TIMEOUT = 30

# Rest des Codes...
```

## ðŸ”„ PRE-COMMIT INTEGRATION

### Automatische Formatierung vor Commits
```yaml
# .pre-commit-config.yaml (bereits konfiguriert)
repos:
  - repo: https://github.com/psf/black
    rev: 24.2.0
    hooks:
      - id: black
        language_version: python3.11
        args: [--target-version=py311]

  - repo: https://github.com/pycqa/isort
    rev: 5.13.2
    hooks:
      - id: isort
        args: ["--profile", "black"]
```

### Developer Workflow
```bash
# 1. Pre-commit Hooks installieren (einmalig)
make pre-commit-install

# 2. Entwicklung - Code wird automatisch formatiert
git add .
git commit -m "New feature"  # Hooks formatieren automatisch

# 3. Manuelle Formatierung (falls nÃ¶tig)
make format
git add .
git commit -m "Feature + Formatierung"
```

## ðŸš€ CI/CD INTEGRATION

### GitHub Actions (automatisch aktiv)
- **Formatierungs-Check**: Bei jedem Push/PR
- **Automatische Reports**: Bei Formatierungsfehlern
- **Enforcement**: PR kann nicht gemerged werden bei Problemen

### Quality Gates
1. **Black-Standard**: 100% Compliance erforderlich
2. **Import-Sortierung**: isort-Compliance erforderlich
3. **Line Length**: Maximal 88 Zeichen
4. **Code Review**: Formatierung wird automatisch geprÃ¼ft

## ðŸ“Š MONITORING UND METRIKEN

### Formatierungs-Compliance
```bash
# WÃ¶chentlicher Report
make format-report

# Violations Report
make black-violations-report

# Live-Check wÃ¤hrend Entwicklung
make check-format
```

### Code-QualitÃ¤ts-Metriken
- **Format-Compliance**: 100% fÃ¼r alle neuen Dateien
- **Pre-commit-Erfolgsrate**: > 95%
- **CI/CD-Failure durch Formatierung**: < 5%

## ðŸŽ¯ ENFORCEMENT UND REGELN

### Obligatorische Anforderungen
âœ… **Alle Python-Dateien mÃ¼ssen Black-konform sein**
âœ… **isort mit Black-Profil fÃ¼r alle Imports**
âœ… **Pre-commit Hooks installiert und aktiv**
âœ… **CI/CD-Checks mÃ¼ssen erfolgreich sein**
âœ… **Code Review berÃ¼cksichtigt Formatierung**

### Ausnahmen (nur in SonderfÃ¤llen)
```python
# fmt: off
manually_formatted_data = [
    [1, 2, 3],
    [4, 5, 6],
    [7, 8, 9]
]
# fmt: on
```

---

## ðŸ”— INTEGRATION MIT ANDEREN REGELN

### Feature Testing Integration
- Test-Code unterliegt denselben Black-Standards
- Test-Fixtures mÃ¼ssen formatiert sein
- Mock-Daten werden automatisch formatiert

### Dokumentations-Integration
- Code-Beispiele in Dokumentation mÃ¼ssen Black-konform sein
- README-Code-BlÃ¶cke werden geprÃ¼ft
- API-Dokumentation verwendet konsistente Formatierung

---

## âš ï¸ MIGRATION UND ADOPTION

### Bestehender Code
1. **Datei-weise Migration**: Ein Service nach dem anderen
2. **Separate Commits**: Formatierung getrennt von Features
3. **Team-Koordination**: Koordinierte Black-Updates

### Neue Entwickler
1. **Onboarding**: Black-Standard in EinfÃ¼hrung
2. **IDE-Setup**: Automatische Formatierung konfigurieren
3. **Training**: Hands-on mit Black und isort

---

## ðŸ“ž SUPPORT UND TROUBLESHOOTING

### HÃ¤ufige Probleme
- **"Line too long"**: Black formatiert automatisch
- **Import-Konflikte**: `isort --profile black` verwenden
- **Pre-commit Fehler**: `make format` vor Commit ausfÃ¼hren

### Hilfe-Kommandos
```bash
make format-help      # Formatierungs-Hilfe
make black-violations-report  # Detaillierte Probleme
make check-format     # Aktuelle Compliance prÃ¼fen
```

---

## ðŸŽ¯ Status: SOFORT AKTIV

**Diese erweiterte Formatierungs-Regel ist SOFORT OBLIGATORISCH fÃ¼r:**
- âœ… Alle neuen Python-Dateien
- âœ… Alle geÃ¤nderten Python-Dateien
- âœ… Alle Commits und Pull Requests
- âœ… CI/CD Pipeline-Validierung
- âœ… Code Review Requirements

**Kein Python-Code ohne Black-Standard-Compliance!** ðŸŽ¨âœ¨

---

*Diese Regeln arbeiten zusammen mit:*
- `.cursorrules/rules/black_standard.md` (Detaillierte Black-Regel)
- `.cursorrules/rules/feature_testing.md` (Test-Standards)
- `.cursorrules/rules/iterative_development.md` (Development-Workflow)
