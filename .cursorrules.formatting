# FORMATIERUNGS-MASTER-REGELWERK FÃœR AI MEDIA ANALYSIS
# Version: 3.0.0 - Bereinigt und Strukturiert
# Status: Master-Regel fÃ¼r alle Code-Formatierung

## ðŸŽ¯ HAUPT-FORMATIERUNGSREGELN (OBLIGATORISCH)

### ðŸ“‹ Regelhierarchie
1. **Black-Standard**: `.cursorrules/rules/black_standard.md` - Strenge Black-Compliance
2. **Linter-Compliance**: `.cursorrules/rules/linter_compliance.md` - VollstÃ¤ndige Linter-Regeln
3. **Testing-Standards**: `.cursorrules/rules/feature_testing.md` - Test-Code-Formatierung
4. **Konfiguration**: `.cursorrules/rules/config_validation.md` - Config-Dateien

---

## âš¡ QUICK REFERENCE

### Automatische Formatierung
```bash
# Alle Formate automatisch anwenden
make format

# Formatierung prÃ¼fen (CI/CD)
make check-format

# Pre-commit Hooks installieren
make pre-commit-install
```

### Black-Standard (PFLICHT)
- **Line Length**: 88 Zeichen
- **Target Version**: Python 3.11+
- **String Quotes**: Doppelte AnfÃ¼hrungszeichen
- **Import Sorting**: isort mit Black-Profil

### Code-Beispiel (Black-konform)
```python
"""Service-Modul mit korrekter Formatierung."""

import os
from typing import Dict, List, Optional

from fastapi import FastAPI
from pydantic import BaseModel


class VideoProcessor(BaseModel):
    """Video-Verarbeitungsservice."""

    name: str
    batch_size: int = 32
    enabled: bool = True


async def process_video(
    video_path: str,
    config: Optional[VideoProcessor] = None,
    *,
    output_format: str = "mp4",
) -> Dict[str, str]:
    """
    Verarbeitet Video-Datei asynchron.

    Args:
        video_path: Pfad zur Eingabe-Videodatei
        config: Optionale Prozessor-Konfiguration
        output_format: Ausgabeformat (mp4, avi, mov)

    Returns:
        Verarbeitungsresultat mit Status und Metadaten

    Raises:
        FileNotFoundError: Wenn Videodatei nicht existiert
        ValueError: Bei ungÃ¼ltigem Ausgabeformat
    """
    if not os.path.exists(video_path):
        raise FileNotFoundError(f"Video nicht gefunden: {video_path}")

    supported_formats = ["mp4", "avi", "mov", "mkv"]
    if output_format not in supported_formats:
        raise ValueError(f"Format {output_format} nicht unterstÃ¼tzt")

    # Multi-line Dictionary mit trailing comma
    result = {
        "status": "success",
        "input_file": video_path,
        "output_format": output_format,
        "processing_time": 0.0,
        "metadata": {
            "batch_size": config.batch_size if config else 32,
            "enabled_features": ["detection", "analysis", "export"],
        },
    }

    return result
```

---

## ðŸ”§ ENTWICKLUNGSWORKFLOW

### 1. Code schreiben
```python
# Entwickle ohne Formatierungs-Sorgen
def my_function(param1, param2):
    return {"result": param1 + param2}
```

### 2. Automatisch formatieren
```bash
# Black + isort automatisch
make format
```

### 3. PrÃ¼fen vor Commit
```bash
# VollstÃ¤ndige PrÃ¼fung
make check-all
```

### 4. Pre-commit Hook (automatisch)
```bash
# Installiert einmalig
make pre-commit-install
# LÃ¤uft dann automatisch bei jedem Commit
```

---

## ðŸ“š DETAILLIERTE REGELN

### ðŸŽ¨ VollstÃ¤ndige Formatierungs-Regeln
- **Datei**: `.cursorrules/rules/black_standard.md`
- **Inhalt**: Komplette Black-Konfiguration, Code-Beispiele, CI/CD-Integration

### ðŸ” Linter-Integration
- **Datei**: `.cursorrules/rules/linter_compliance.md`
- **Inhalt**: flake8, mypy, bandit, safety Integration

### ðŸ§ª Test-Code-Formatierung
- **Datei**: `.cursorrules/rules/feature_testing.md`
- **Inhalt**: Test-spezifische Formatierungs-Standards

### âš™ï¸ Konfigurations-Validierung
- **Datei**: `.cursorrules/rules/config_validation.md`
- **Inhalt**: YAML, TOML, JSON Formatierung

---

## ðŸš¨ ENFORCEMENT

### CI/CD Pipeline
- **GitHub Actions**: Automatische Format-Checks
- **Pre-commit**: Lokale Format-Enforcement
- **Make Targets**: Einfache Automatisierung

### Quality Gates
- **Format Check**: Blockiert bei Format-Fehlern
- **Linter Check**: Blockiert bei Linter-Fehlern
- **Type Check**: Blockiert bei Type-Fehlern

### Developer Tools
- **VSCode**: Automatische Format-on-Save
- **PyCharm**: Black-Integration
- **Vim/Neovim**: Black-Plugin

---

## ðŸŽ¯ MIGRATIONS-GUIDE

### Bestehenden Code formatieren
```bash
# Alle Python-Dateien formatieren
make format-all

# Nur Services formatieren
make format-services

# Nur Tests formatieren
make format-tests
```

### Gradueller Rollout
1. **Phase 1**: Core-Services formatieren
2. **Phase 2**: Test-Suite formatieren
3. **Phase 3**: Scripts und Tools formatieren
4. **Phase 4**: Legacy-Code schrittweise

### Konflikt-Resolution
- **Merge-Konflikte**: `make format` lÃ¶st die meisten Probleme
- **Stil-Diskussionen**: Black entscheidet - keine Diskussion
- **Legacy-Code**: Schrittweise Migration mit separaten PRs

---

## ðŸ“ˆ ERFOLGS-METRIKEN

### Code-Quality-Metriken
- **Format-Compliance**: 100% Black-konform
- **Import-Organisation**: 100% isort-konform
- **Type-Coverage**: >90% Type-Annotationen
- **Linter-Score**: Null Linter-Warnings

### Developer-Experience-Metriken
- **Format-Zeit**: <5 Sekunden fÃ¼r full format
- **CI-Zeit**: <2 Minuten fÃ¼r Format-Checks
- **Konflikt-Rate**: <5% Format-bedingte Merge-Konflikte

---

## ðŸ”— VERWANDTE REGELN

- **Black-Standard**: `.cursorrules/rules/black_standard.md`
- **Linter-Compliance**: `.cursorrules/rules/linter_compliance.md`
- **Feature-Testing**: `.cursorrules/rules/feature_testing.md`
- **Config-Validation**: `.cursorrules/rules/config_validation.md`
- **Venv-Development**: `.cursorrules/rules/venv_development.md`
- **Iterative-Development**: `.cursorrules/rules/iterative_development.md`

**ðŸ“‹ VollstÃ¤ndige Regel-Ãœbersicht**: `.cursorrules/README.md`
